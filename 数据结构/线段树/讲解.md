### 问题提出

**题目一**：
10000个正整数，编号1到10000，用A[10000]表示。
修改：无
统计：1.编号从L到R的所有数之和为多少？ 其中1<= L <= R <= 10000.

方法一：对于统计L,R ，需要求下标从L到R的所有数的和，从L到R的所有下标记做[L..R],问题就是对A[L..R]进行求和。

这样求和，对于每个询问，需要将(R-L+1)个数相加。

方法二：更快的方法是求**前缀和**,令 S[0]=0, S[k]=A[1..k] ，那么，A[L..R]的和就等于S[R]-S[L-1]，

这样，对于每个询问，就只需要做一次减法，大大提高效率。

**题目二**：

10000个正整数，编号从1到10000，用A[10000]表示。

修改：1.将第L个数增加C （1 <= L <= 10000）

统计：1.编号从L到R的所有数之和为多少？ 其中1<= L <= R <= 10000.

再使用方法二的话，假如A[L]+=C之后，S[L],S[L+1],,S[R]都需要增加C,全部都要修改，见下表。

||方法一|方法二|
|-|-|-|
|A[L]+=C|修改1个元素|修改R-L+1个元素|
|求和A[L..R]|计算R-L+1个元素之和|计算两个元素之差|
||**修改快，求和慢**|**求和快，修改慢**|

那有没有一种结构，**既要**修改快**，又要**求和快呢？答案当然是线段树。

#### **从前缀和的角度理解线段树：**

1. 前缀和单向递增，靠后的前缀和包含了前面所有的数据，每次修改要调整的频率很高。

2. 使用二分法来构造一个层级结构（**树的层级有限性**），任意区间只需要在这个层级结构中找到对应的统计值。但要求底层统计值能直接计算出上层的统计值。

3. 用树的区间累积的**层级结构**来代替前缀和单向递增的**线性结构**。直接在数组上构造完全二叉树。

![..\refer\acm_xds001.png](..\refer\acm_xds001.png)

#### HDU1754 I HATE IT（仅点修改）

[HDU1754 I HATE IT](http://acm.hdu.edu.cn/showproblem.php?pid=1754)

题目大意：Q A B询问学号从A到B的学生的最高分；U A B将学号A的成绩改为B。

询问区间的最高分，单点修改某个学生的分数。

```C++
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<string.h>
using namespace std;

const int N=200000;
int num[N+5];
struct node
{
    int l,r,maxx;
}tree[N*4];//一般要开四倍

void bulid(int rt,int l,int r)
{//rt-当前节点下标，l-区间左，r-区间右，初始为1,1,n
    tree[rt].l=l;
    tree[rt].r=r;
    tree[rt].maxx=-1;
    
    if(tree[rt].l==tree[rt].r){//叶节点
        tree[rt].maxx=num[l];
        return ;
    }
    
    int mid=(tree[rt].l+tree[rt].r)/2;
    bulid(rt<<1,l,mid);//建左子树
    bulid(rt<<1|1,mid+1,r);//建右子树
    tree[rt].maxx=max(tree[rt<<1].maxx,tree[rt<<1|1].maxx);//当前区间统计值
}

///区间查询
int query(int rt,int l,int r)
{//rt-当前节点下标，初始为根节点1；l-要查询的左边界；r-要查询的右边界
    if(tree[rt].l>=l&&tree[rt].r<=r){//当前节点的范围完全[l,r]之内
        return tree[rt].maxx;
    }
    
  	//寻找[tree[rt].l,tree[rt].r]与[l,r]重叠的各个子区间
    int res=-1;
    int mid=(tree[rt].l+tree[rt].r)/2;
    if(l<=mid)
        res=max(res,query(rt<<1,l,r));//如果l小于等于mid 需要对左孩子进行查询
    if(r>=mid+1)
        res=max(res,query(rt<<1|1,l,r));//如果r大于等于mid+1 需要对右孩子进行查询
    return res;//将res值返回
}

///单点更新
void update(int rt,int where,int val)
{//rt-当前节点，初始为根节点1；where-要更新的节点下标；val-要更新的值
    if(tree[rt].l==tree[rt].r){//叶节点
        tree[rt].maxx=val;
        return ;
    }
    
    int mid=(tree[rt].l+tree[rt].r)/2;
    if(where<=mid)
        update(rt<<1,where,val);
    if(where>=mid+1)
        update(rt<<1|1,where,val);
    
    tree[rt].maxx=max(tree[rt<<1].maxx,tree[rt<<1|1].maxx);//更新当前节点
    return ;
}

int main()
{
    int n,m,x,y;
    char a[10];
    while(scanf("%d%d",&n,&m)!=EOF){
        for(int i=1;i<=n;i++)
            scanf("%d",&num[i]);
        bulid(1,1,n);
        for(int i=1;i<=m;i++){
            scanf("%s",a);
            scanf("%d%d",&x,&y);
            if(a[0]=='Q'){
                printf("%d\n",query(1,x,y));
            }
            else if(a[0]=='U'){
                update(1,x,y);
            }
        }
    }
    return 0;
}

```

### 应用

要求解的问题：针对一个离散序列（点），求其**某个区间的统计值**。

4. 下标区间[L, R]：指的是离散序列的下标范围，并不是序列中存储的值。

5. 区间**“加法”**： **用线段树统计的东西必须符合区间加法**，即可直接通过子区间来得到父区间的统计值。

6. 数据结构：用**数组来表示的完全二叉树**，离散序列中树的叶节点，向上的分支节点表示序列的一段下标区间。

  7. 每一个节点R ,左子节点为 2*R (一般写作R<<1)右子节点为 2*R+1（一般写作R<<1|1），以1为根节点 。

  8. 如序列个数为n（二叉树最底层叶节点的个数），则层数应为[log~~2~~n]+2（[]表示向下取整，根节点算一层），总的节点数为pow(2, [log~~2~~n]+2)-1。一般都开4倍空间，比如： int A[n<<2] 。

9. 点修改：离散序列中的某些值会发生改变，依次修改该点的祖先节点即可。

  10. 修改和统计的复杂度都是O(log2(n)) 。

11. 区间查询：给定一个区间[L, R]，找到代表该区间的所有节点。原则：能用区间（上层分支节点）尽量用区间。

12. 区间修改：按区间查询的结束，一般不立即更新相关的所有节点，而是在区间节点上加一个**懒惰标记**，更新该区间节点的统计值，但不更新下级节点的统计值。

  13. 相对标记：与标记的顺序无关，如各节点加上一个数。

  14. 绝对标记：与标记的顺序有关，如设置各节点为某一个数。

  15. 如果同时有相对标记和绝对标记，则要设置两个标记，下推时两个标记同时下推，且绝对标记要优先于相对标记。

#### 思维逻辑

![..\refer\acm_xds002.png](..\refer\acm_xds002.png)

**符合区间加法的例子：**

能直接从左右两个子区间的统计值获得上一级统计值

16. 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和

17. 极值——总极值=max(左区间极值，右区间极值)

18. 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );

**不符合区间加法的例子：**

19. 众数——只知道左右子区间的众数，没法求总区间的众数

20. 01序列的最长连续零——只知道左右子区间的最长连续零，没法知道总的最长连续零

### 模板

```C++
#define maxn 100007  //元素总个数
int Sum[maxn<<2],Add[maxn<<2];//Sum求和，Add为懒惰标记 
int A[maxn],n;//存原数组数据下标[1,n]

//上推区间统计值：自下向上更新区间统计值，根据两个子节点计算上级节点统计值 ，这里是求和
void PushUp(int rt){
    Sum[rt]=Sum[rt<<1]+Sum[rt<<1|1];
}

//Build函数建树 
void Build(int l,int r,int rt){ //l,r表示当前节点对应的原始序列区间，rt表示当前的树节点编号
	if(l==r) {//若到达叶节点 
		Sum[rt]=A[l];//储存数组值 
		return;
	}
	int m=(l+r)>>1;
	//左右递归 
	Build(l,m,rt<<1);
	Build(m+1,r,rt<<1|1);
	//由两个子树上推区间统计值 
	PushUp(rt);
}

//点修改，一旦原始数组A建了树之后，就得在树里修改数据，所以要找到相应的叶节点。
void UpdateNode(int L,int C,int l,int r,int rt)
{//L原始数据下标；C是要增加的值；l,r和rt是当前树节点信息，rt表示[l,r]区间所对应的树节点编号
	if(l==r){//到叶节点，修改 
		Sum[rt]+=C;
		return;
	}
	int m=(l+r)>>1;
	//根据条件判断往左子树调用还是往右 
	if(L <= m) 
        UpdateNode(L,C,l,m,rt<<1);
	else       
        UpdateNode(L,C,m+1,r,rt<<1|1);
	//计算rt的统计值。L一定落在rt子树里，所以对rt有影响
	PushUp(rt);//子节点更新了，所以本节点也需要更新信息 
}

//区间修改
void UpdateSpan(int L,int R,int C,int l,int r,int rt)
{//L,R表示操作区间，l,r表示当前子树，rt表示[l,r]对应的树节点编号 
	if(L <= l && r <= R){//如果子树完全在操作区间[L,R]以内 
		Sum[rt]+=C*(r-l+1);//更新数字和，向上保持正确
		Add[rt]+=C;//增加Add标记，表示本区间的Sum正确，子区间的Sum仍需要根据Add的值来调整
		return ; 
	}
	int m=(l+r)>>1;
    
    //子树区间[l,r]与操作区间[L,R]有交叉，则需与下推懒惰标记
  	//仅修改下一级rt<<1和rt<<1|1，清除rt
	PushDown(rt,m-l+1,r-m);
    
	//这里判断左右子树跟[L,R]有无交集，有交集才递归 
	if(L <= m) 
        UpdateSpan(L,R,C,l,m,rt<<1);
	if(R > m) 
        UpdateSpan(L,R,C,m+1,r,rt<<1|1); 
	PushUp(rt);//更新本节点信息，下级变化一定要更新上级节点，反之不亦然（懒惰标记）
}

//下推懒惰标记：自上向下更新懒惰标记，由上级节点的懒惰标记，更新下级节点的统计值并添加懒惰标记
void PushDown(int rt,int ln,int rn){
	//ln,rn为左子树，右子树的元素数量，要同步更新SUM，是Add的倍数。 
	if(Add[rt]){
		//下推标记 
		Add[rt<<1]+=Add[rt];
		Add[rt<<1|1]+=Add[rt];
      
		//修改子节点的Sum使之与对应的Add相对应 
		Sum[rt<<1]+=Add[rt]*ln;
		Sum[rt<<1|1]+=Add[rt]*rn;
      
		//清除本节点标记 
		Add[rt]=0;
	}
}

//区间查询
int Query(int L,int R,int l,int r,int rt)
{//L,R表示要查询的区间，l,r表示当前节点区间，rt表示[l,r]对应的树节点编号
	if(L <= l && r <= R){
		//在区间内，直接返回 
		return Sum[rt];
	}
	int m=(l+r)>>1;
  
	//下推标记，否则Sum可能不正确
	PushDown(rt,m-l+1,r-m); 
	
	//累计答案
	int ANS=0;
	if(L <= m) 
        ANS+=Query(L,R,l,m,rt<<1);
	if(R >  m) 
        ANS+=Query(L,R,m+1,r,rt<<1|1);
	return ANS;
}

//建树 
Build(1,n,1); 
//点修改
UpdateNode(L,C,1,n,1);
//区间修改 
UpdateSpan(L,R,C,1,n,1);
//区间查询 
int ANS=Query(L,R,1,n,1);
```

### 例题

#### URAL 1989 Subpalindromes（哈希+线段树）

题目大意：输入一个字符串，两种操作：chane i a将字符串第i个字符改为a；palindrome? j k询问从j到k的子串是否是回文串。

- 字符串转化为一个与顺序有关、可区间加法的哈希值a[0]+a[1]*K + a[2]*K^2 +...+a[n-1]*K^(n-1)。

- 分别维护字符串正序、逆序两个哈希值的线段时，如果进行区间查询，两个树上的哈希值是相同的，则字符串是回文串的可能性就非常大了。

```C++
#include <cstdio>
#include <cstring>
#include <string>
#include  <iostream>
#include <algorithm>
#include <map>

typedef unsigned long long ull;
using namespace std;

const int maxn = 1e5 + 5;
const int has = 131;
char str[maxn];
int len, n;
char op[20];
ull sum[2][maxn << 2];//正序、逆序两个线段树
ull p[maxn << 2];//素数的幂

//上推区间统计值，字符串顺序一致，仅哈希值计算的方向逆转，效果是一样的，哈希就一个值而已
void pushup(int rt, int l, int r) 
{//rt-要更新的节点；l-左区间宽度；r-右区间宽度
    sum[0][rt] = sum[0][rt << 1] + sum[0][rt << 1 | 1] * p[l];
    sum[1][rt] = sum[1][rt << 1] * p[r] + sum[1][rt << 1 | 1] ;
}

//建树
void build(int l, int r, int rt) {
    if(l == r) {
        sum[0][rt] = sum[1][rt] = str[l];
        return ;
    }
    int m = (l + r) >> 1;
    build(l, m, rt<<1);
    build(m+1, r, rt<<1|1);
    pushup(rt, m - l + 1, r - m);
}

//点修改
void update(int pos, char a, int l, int r, int rt) 
{//pos-字符串的下标；a-修改后的字符；l-区间左边界；r-区间右边界；rt-当前节点
    if(l == r) {
        str[pos] = a;
        sum[0][rt] = sum[1][rt] = str[pos];
        return ;
    }
    int m = (l + r) >> 1;
    if(m >= pos) 
        update(pos, a, l, m, rt<<1);
    else 
        update(pos, a, m+1, r, rt<<1|1);
    pushup(rt, m - l + 1, r - m);
}

//区间查询，判断[L,R]之间的字符串是否是回文串。
ull query(int flag, int L, int R, int l, int r, int rt) 
{//flag-正序还是逆序哈希；L-要查询区间的左边界；R-要查询区间的右边界；l-当前区间左边界；r-当前区间右边界；rt-当前节点；
    
    if(L <= l && R >= r) {//当前区间被包含
        return sum[flag][rt];
    }
    
    int m = (l + r) >> 1;
    ull ans1 = 0, ans2 = 0, ans = 0, t = 0;
    if(L <= m) {//是要对t进行分类讨论的
        t += 1;//1
        ans1 = query(flag, L, R, l, m, rt<<1);
    }
    if(R > m) {
        t += 2;//2,3
        ans2 = query(flag, L, R, m+1, r, rt<<1|1);
    }
    if(t == 1) //[L,m]
        ans = ans1;
    else if(t == 2) //[m,R]
        ans = ans2;
    else if(t == 3) {//[L,m]和[m,R]
        if(flag == 0) {
            ans = ans1 + ans2 * p[m - max(l, L) + 1];//右侧要乘的幂
        } 
        else if(flag == 1) {
            ans = ans1 * p[min(R, r) - m] + ans2;
        }
    }
    return ans;
}

int main() {
    scanf("%s%d", str + 1, &n);
    len = strlen(str + 1);
    
    //计算素数has的幂，以便于后面计算字符串的哈希值
    p[0] = 1;
    for(int i = 1; i <= len; i++) 
        p[i] = p[i - 1] * has;
    
    //建树
    build(1, len, 1);
    
    while(n--) {
        int a;
        scanf("%s %d", op, &a);
        if(op[0] == 'p') {
            int b;
            scanf("%d", &b);
            ull a1 = query(0, a, b, 1, len, 1);
            ull a2 = query(1, a, b, 1, len, 1);
            if(a1 == a2) 
                printf("Yes\n");
            else 
                printf("No\n");
        } 
        else if(op[0] == 'c') {
            char b;
            cin >> b;
            update(a, b, 1, len, 1);
        }
    }
    return 0;
}
```

#### 数据离散化

[https://blog.csdn.net/qq_21433411/article/details/86678427](https://blog.csdn.net/qq_21433411/article/details/86678427)

题目大意：有一个长为10000000的墙，有1 <= n <= 10000个市长候选人去张贴海报，每个人的海报长度不限。上面的海报会覆盖下面的海报，问你最后能看见哪些海报。

- 直接用墙长度作为下标，要开的线段树太大导致MLE。实际上我们只关心每个海报的两个端点，对端点排序后就可以知道相互的覆盖关系，并不需要具体的长度。

- 只有如果每张海报的端点都不同，也只需要2*n个节点就行了。

![4f728f19388cf4283d63ffb5faa6804b_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNDMzNDEx,size_16,color_FFFFFF,t_70.png](线段树+8429e80d-61ae-4993-8504-c845e1faf42b/4f728f19388cf4283d63ffb5faa6804b_watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNDMzNDEx,size_16,color_FFFFFF,t_70.png)

如果数据范围特别大，但可能有很多重复的，可以只记录没重复的数据。

### 参考资料

[https://blog.csdn.net/zearot/article/details/52280189](https://blog.csdn.net/zearot/article/details/52280189) 线段树从零开始

[https://blog.csdn.net/zearot/article/details/48299459](https://blog.csdn.net/zearot/article/details/48299459) 线段树详解


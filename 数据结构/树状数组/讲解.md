树状数组是一个查询和修改复杂度都为log(n)的数据结构。主要用于数组的**单点修改**、**区间求和**。

#### 与线段树的差异

1. 两者在**计算复杂度上同级**, 但是树状数组需要的**空间**（N）明显优于线段树（4N）, 其**编程复杂度也远小**于线段树。

2. 树状数组的作用被线段树完全涵盖, 凡是可以使用树状数组解决的问题, 使用线段树一定可以解决, 但是线段树能够解决的问题树状数组未必能够解决。

3. 树状数组的突出特点是其编程的极端简洁性, 使用lowbit技术可以在很短的几步操作中完成树状数组的核心操作，其代码效率远高于线段树。

#### 二叉树的画法

![..\refer\acm_szsz01.png](..\refer\acm_szsz01.png)

- 在线段树上，存储了这个二叉树的每一个节点，所以需要的存储空间是原数组的4倍。

![..\refer\acm_szsz02.png](..\refer\acm_szsz02.png)

#### 映射方式

- 只在二叉树上选择N个节点存储原始数据和统计数据，显然有些节点要放弃不存储，那么必然要放弃一些叶节点（原始数据），而用分支节点（统计数据）来代替，这也是为什么树状数组的功能要弱于线段树。

- 将原离散序列按N:N的方式映射为一个可以存储区间统计值的二叉树，能推导就尽可能推导出来（**由父节点与左分支推导出右分支**）。

  - 左分支都保留，则**奇数下标的叶节点**都应该保留。

  - 不作为上一级右分支存在的父节点都保留，即**每个子树的最左侧DFS路径（不含根节点）**都保留。整个树来看，恰好$2^n$下标的节点都保留。

  - 找规律：二进制低位有几个零，代表下面有几层分支（子树的层次），就有几个右分支被省略（空）。

![..\refer\acm_szsz03.png](..\refer\acm_szsz03.png)

![..\refer\acm_szsz04.png](..\refer\acm_szsz04.png)

#### 低位1（lowbit技术）

**低位1**：最低一位1及其低位上的零组成的数据，如1100的低位1为100。

**操作方法**：每次加上低位1即为上级节点，如101+1=>110; 110+10=>1000; 1000+1000=>10000;

- 更新：从叶节点开始，一直到达n，

**如何求低位1（ x&(-x) ）**

一个数的负数就等于对这个数取反+1。

二进制数11010为例:11010的补码为00101,加1后为00110,两者相与便是最低位的1。

```C++
//求低位1
int lowbit(x){
    return x&(-x);
}
```

#### 区间查询（自下而上的蓝色箭头）

4. 用**前缀和的差分思维**，即区间[x1,x2]=[1,x2]-[1,x1]。

  5. 不满足差分运算的统计值就不能用，例如极值问题。

6. 从区间右侧的叶节点出发，将其左侧的有统计值的子树根节点逐个加起来。

**寻找左侧有统计值的子树根节点**

```C++
//求[1,x]的区间和，如果想求区间[x1,x2]，可以用差分思维，即[1,x2]-[1,x1]
int getsum(int x){
    int ans = 0;
    for(int i=x;i;i-=lowbit(i))//寻找相邻的左侧子树
        ans += c[i];
    return ans;
}
```

#### 单点修改（自下而上的绿色箭头）

7. 要修改的下标对应的树节点可能是统计值，一定包含当前要修改的节点。

8. 加上低位1可以找到包含其统计值的上一级节点（统计意义，而不是树结构意义上的上级）。

```C++
//下标x处的数据加y，n为原始数组长度
void update(int x,int y,int n){
    //x为首个要更新的叶节点（奇数下标）或分支节点（偶数下标，其下方节点不在树中记录）
    for(int i=x;i<=n;i+=lowbit(i))//不断向树状数组的上级迭代
        c[i] += y;
}
```

#### 例题

#### HDU1166 敌兵布阵

[http://acm.hdu.edu.cn/showproblem.php?pid=1166](http://acm.hdu.edu.cn/showproblem.php?pid=1166)

一个比较基础的单点修改和区间求和的例子。

```C++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <string>
#include <vector>
#define For(a,b) for(int a=0;a<b;a++)
#define mem(a,b) memset(a,b,sizeof(a))
#define _mem(a,b) memset(a,0,(b+1)<<2)
#define lowbit(a) ((a)&-(a))
using namespace std;
typedef long long ll;
const int maxn =  5*1e4+5;
const int INF = 0x3f3f3f3f;
int c[maxn];
void update(int x,int y,int n){
    for(int i=x;i<=n;i+=lowbit(i))
        c[i] += y;
}
int getsum(int x){
    int ans = 0;
    for(int i=x;i;i-=lowbit(i))
        ans += c[i];
    return ans;
}
int main()
{
    int t;
    int n;
    int x,y,z;
    string s;
    cin >> t ;
    for(int j=1;j<=t;j++){
        scanf("%d",&n);
        _mem(c,n);      //初始化数组中前n+1个数为0
        for(int i=1;i<=n;i++){
            scanf("%d",&z);
            update(i,z,n);
        }
        cout <<"Case "<<j<<":"<<endl;
        while(1){
            cin >> s;
            if(s[0] == 'E')
                break;
            scanf("%d%d",&x,&y);
            if(s[0] == 'Q')
                cout << getsum(y)-getsum(x-1)<<endl;
            else if(s[0] == 'A')
                update(x,y,n);
            else
                update(x,-y,n);
        }
    }
    return 0;
}
```

### 扩展

把树状数组看成是一种快速获得**动态前缀和**的有效方法。

#### 区间修改+单点查询

**原数组变换为差分数组**

设原数组为a[i]，定义新的差分数组d[i]=a[i]-a[i-1] (a[0]=0)，则d[i]数组的前缀和即为a[i]。

**原数组的区间修改变换为差分数组的两个单点修改**

原数组a[i]进行区间修改，[l,r]之间各加上x，则在差分数组d[i]中，实质上等同于d[l]=a[l]-a[l-1]要增加x，在d[r+1]=a[r+1]-a[r]要减去x。

这样就转化为树状数组上的单点修改+区间查询的问题。

#### 区间修改+区间查询

同上：设原数组为a[i]，定义新的差分数组d[i]=a[i]-a[i-1] (a[0]=0)，则d[i]数组的前缀和即为a[i]。

区间查询就是要查a[i]的前缀和

$\sum\limits_{j=1}^{i}a[j]=\sum\limits_{j=1}^{i}\sum\limits_{k=1}^{j}d[k]
=d[1]*i+d[2]*(i-1)+...+d[i]*1=\sum\limits_{j=1}^{i}d[j]*(i-j+1)
=(i+1)*\sum\limits_{j=1}^{i}d[j]-\sum\limits_{j=1}^{i}d[j]*j$

即，a[i]的前缀和转换为d[i]和d[i]*j这两个前缀和的问题。

```C++
int N;
ll C[MAXN],C2[MAXN]; //分别记录d[i]和d[i]*i的树状数组（前缀和）
int lowbit(int x){return x&(-x);}
void init(int n) //初始化共有n个点
{
  N=n;
  memset(C,0,sizeof(C));
  memset(C2,0,sizeof(C2));
}
void add(int pos,ll val)
{
  for(int i=pos;i<=N;i+=lowbit(i)) C[i]+=val,C2[i]+=val*pos;
}
void range_add(int l,int r,ll x) //区间[l,r]加上x
{
  add(l,x);
  add(r+1,-x);
}
ll ask(int pos)
{
  ll ret=0;
  for(int i=pos;i>0;i-=lowbit(i)) ret+=(pos+1)*C[i]-C2[i];
  return ret;
}
ll range_ask(int l,int r) //查询区间[l,r]的和
{
  return ask(r)-ask(l-1);
}
```

#### 单点修改，区间极值查询

子树表示一个区间的极值，查询一个区间包含哪些子树

去掉不表示的节点，树状数组又可看成是一种多叉树，自上而下遍历子节点的方式就是用父节点的下标减去比自己的lowbit更小的所有2的k次方。

#### 二维区间加减，区间求和

每个点(x,y)，连接到(x + lowbit(x), y)，以及(x, y + lowbit(y)) 两个节点上。每个点维护平面上的前缀和，即矩阵的前缀和，如下图所示，点(x,y)维护左上角矩阵的和。

![0b30bec6b9b878f3e1d96459e9ff2232_v2-642f274fae44af350684acabb2352fc3_720w.webp](树状数组+5953e688-20ec-47e5-9266-29b6b66901d9/0b30bec6b9b878f3e1d96459e9ff2232_v2-642f274fae44af350684acabb2352fc3_720w.webp)

#### 参考文献

[zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/546893960)

